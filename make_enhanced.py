#!/usr/bin/python3

from textwrap import dedent # to dedent the new code for test_script.py
import sys
import re   # regular expressions
from make_enhanced_utils import make_wait_command

golden_file_name = "golden.py"
enhanced_file_name = "enhanced.py"

# Read golden file into memory as a list of lines
with open(golden_file_name, 'r') as gf:
    lines = gf.read().splitlines()

## Add the imports we need
# look for the first line that starts with "from selenium" and add our imports
# before the selenium imports
import_inspect = "from inspect import currentframe, getframeinfo"
import_our_functions = "import functions"
import_re = "import re"
import_sys = "import sys"
import_pattern = "^from\s+selenium"
import_found = False
for line_num, line in enumerate(lines):
    match = re.match(import_pattern, lines[line_num])
    if match != None:
        # found line that imports from selenium. Insert our imports above
        # this line and break out of loop
        lines.insert(line_num, import_inspect)
        lines.insert(line_num, import_our_functions)
        lines.insert(line_num, import_re)
        lines.insert(line_num, import_sys)
        import_found = True
        break
if import_found == False:
    sys.exit("Failed to add necessary imports")


# Insert declaration for list user_actions just before definition of
# test class generated by Selenium
line_to_insert = "user_responses = list()  # list of user specified actions"
class_def_pattern = "^class\s+"
class_def_found = False
for line_num, line in enumerate(lines):
    match = re.match(class_def_pattern, line)
    if match != None:
        # found line with class definition.  Insert declaration and break
        # out of loop
        lines.insert(line_num, "")
        lines.insert(line_num, line_to_insert)
        class_def_found = True
        break
if class_def_found == False:
    sys.exit("Failed to add declaration for list user_responses")


## Add explicit waits for certain HTML elements to be loaded (e.g. start
## button, canvas, etc)
# To add an explicit wait, call function make_wait_command with max time to
# wait and how the element is found by Selenium (e.g. By.NAME).
# The return value will a list of strings, where each string is a line to be
# inserted into the enhanced script
# Add explicit wait for start button (By.name, "control").
control_btn_pattern = '\s*self\.driver\.find_element\(By.NAME, "control"\)'
cmd_to_insert = make_wait_command(120, 'By.NAME, "control"') 
for line_num, line in enumerate(lines):
    match = re.match(control_btn_pattern, line)
    if match != None:
        # found line that clicks control button.  Insert wait for button to be
        # clickable and exit
        
        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # Form the line to write with num_spaces in front of the command to
        # insert.  To do this find the total length of the line to be inserted
        # (num of spaces + length of the command), and write the command to a
        # string with right justification
        num_lines_inserted = 0
        for l in cmd_to_insert:
            total_line_len = num_spaces + len(l)
            line_to_insert = l.rjust(total_line_len, ' ')

            # insert line after current line
            lines.insert(line_num+num_lines_inserted, line_to_insert)
            num_lines_inserted += 1
        break

# Add explicit wait for canvas to be ready AFTER start ("control") button
# is clicked
control_btn_pattern = '\s*self\.driver\.find_element\(By.NAME, "control"\)'
cmd_to_insert = make_wait_command(360, 'By.CSS_SELECTOR, "canvas"')
for line_num, line in enumerate(lines):
    match = re.match(control_btn_pattern, line)
    if match != None:
        # found line that clicks control button.  Insert wait for canvas 
        # to load after control button is clicked.

        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # Form the line to write with num_spaces in front of the command to
        # to insert
        num_lines_inserted = 0
        for l in cmd_to_insert:
            total_line_len = num_spaces + len(l)
            line_to_insert = l.rjust(total_line_len, ' ')

            # insert line after current line
            lines.insert(line_num+num_lines_inserted+1, line_to_insert)
            num_lines_inserted += 1
        break

# Add explicit wait before click of button confirming ending of lab
confirm_end_btn_pattern = '^\s*self\.driver\.find_element\(By.ID, "btnConfirmEndExercise"\)'
cmd_to_insert = make_wait_command(120, 'By.ID, "btnConfirmEndExercise"')
for line_num, line in enumerate(lines):
    match = re.match(confirm_end_btn_pattern, line)
    if match != None:
        # found line that clicks button to confirm ending lab.
        # Insert wait for button to load

        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # Form the line to write with num_spaces in front of the command to
        # to insert
        num_lines_inserted = 0
        for l in cmd_to_insert:
            total_line_len = num_spaces + len(l)
            line_to_insert = l.rjust(total_line_len, ' ')

            # insert line after current line
            lines.insert(line_num+num_lines_inserted, line_to_insert)
            num_lines_inserted += 1
        break
    

## Add call to function.prompt_user before any action on canvas
canvas_action_pattern = '^\s*\w+\s*=\s*self\.driver\.find_element\(By\.CSS_SELECTOR, "canvas"\)'
cmd_to_insert = "user_responses.append((getframeinfo(currentframe()).lineno, functions.promptUser()))" # adds a tuple with the line number and the user response to the list
line_num = 0 # current line number in lines being processed
while line_num < len(lines):
    match = re.match(canvas_action_pattern, lines[line_num])
    if match != None:
        # found line with action on canvas.  Insert call to prompt_user after
        # this line

        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # add necessary number of spaces before cmd_to_insert 
        total_line_len = num_spaces + len(cmd_to_insert)
        line_to_insert = cmd_to_insert.rjust(total_line_len, ' ')

        # insert line before current line and increment line_num
        lines.insert(line_num, line_to_insert)
        line_num += 1  # since we added a line
    line_num += 1  # go to next line
    
## find name of the test class and test method created by Selenium
test_class_name = test_method_name = None
curr_line_num = 0
while test_class_name == None or test_method_name == None:
    if re.match("^\s*class\s+", lines[curr_line_num]) != None: 
        # Found line that starts with "class ". Get the second part of the line
        # which will have the name of the class
        test_class_name = lines[curr_line_num].split()[1]

        # Get rid of the "():" that is appended to the class name
        test_class_name = test_class_name.replace("():", "")

    if re.match("^\s*def\s*test_", lines[curr_line_num]) != None:
        # Found line that starts "def test_".  Get the second part of the line
        # which will have the name of the method
        test_method_name = lines[curr_line_num].split()[1]

        # Get rid of the "(self):" that is appended to the method name
        test_method_name = test_method_name.replace("(self):", "") 

    curr_line_num += 1

# inserts calls to create test class and to run test
lines.insert(len(lines)+1, "\ntestClass = " + test_class_name + "()")
lines.insert(len(lines)+1, 'testClass.setup_method("")')
lines.insert(len(lines)+1, "testClass." + test_method_name + "()")
lines.insert(len(lines)+1, 'testClass.teardown_method("")')

# add code to create test_script after everything else
curr_line_num = len(lines)+1

# Writing the code to create test_script.py in a multi-lined String
test_script_code = dedent("""
    current_file = 'enhanced.py'
    new_file = 'test_script.py'

    with open(current_file, 'r') as gf:
      lines = gf.read().splitlines()

    prompt_user_pattern = "^\s*user_responses\.append\(\(getframeinfo\(currentframe\(\)\)\.lineno, functions\.promptUser\(\)\)\)" 
    line_num = 0
    for line_num, line in enumerate(lines):
      while line_num < len(lines):
        # Check for a line that contains prompt_user
        match = re.match(prompt_user_pattern, lines[line_num])
        if match != None:
          for item_num, item in enumerate(user_responses):
            # Check to make sure that the current line matches with a line from user_responses
            if (line_num+1) == user_responses[item_num][0]:
              args = user_responses[item_num][1]
              action = args[0]
              arg1 = ""
              arg2 = ""
              match action:
                case "noop":
                  arg1 = "()"
                case "Wait":
                  arg1 = ''.join(map(str, args[1]))
                case "KeyboardInput":
                  arg1 = args[1]
                case "MouseClick":
                  action_args = args[1]
                  x_coord = action_args[0]
                  y_coord = action_args[1]
                  arg1 = str(x_coord)
                  arg2 = str(y_coord)
                  arg1 = arg1 + ", " + arg2
              lines.insert(line_num, 'perform_action((' + action + ', (' + arg1 + ')))')
              lines.pop(line_num+1)
          break        
        else:
          line_num += 1

    with open(new_file, 'w') as ef:
        for line_num, line in enumerate(lines):
            ef.write(line + "\\n")

    sys.exit("Created file " + new_file)
    """)

# Add the new code for the test_script to the file in memory
lines.insert((curr_line_num), test_script_code)

# done inserting lines.  Write all lines to enhanced file
with open(enhanced_file_name, 'w') as ef:
    for line_num, line in enumerate(lines):
        ef.write(line + '\n')

sys.exit("Created file " + enhanced_file_name)

# for each action collected in list user_responses:
#   * go to line number of response (that line will have the call to prompt_user
#   * replace line with perform_action(ACTION_FROM_USER_RESPONSES)
#   * write contents of line array to file test_script.py
