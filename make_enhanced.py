#!/usr/bin/python3

import sys
import re   # regular expressions
from make_enhanced_utils import make_wait_command

golden_file_name = "golden.py"
enhanced_file_name = "enhanced.py"

# Read golden file into memory as a list of lines
with open(golden_file_name, 'r') as gf:
    lines = gf.read().splitlines()

## Add the imports we need
# look for the first line that starts with "from selenium" and add our imports
# before the selenium imports
import_inspect = "from inspect import currentframe, getframeinfo"
import_our_functions = "import functions"
import_pattern = "^from\s+selenium"
import_found = False
for line_num, line in enumerate(lines):
    match = re.match(import_pattern, lines[line_num])
    if match != None:
        # found line that imports from selenium. Insert our imports above
        # this line and break out of loop
        lines.insert(line_num, import_inspect)
        lines.insert(line_num, import_our_functions)
        import_found = True
        break
if import_found == False:
    sys.exit("Failed to add necessary imports")


# Insert declaration for list user_responses just before definition of
# test class generated by Selenium
line_to_insert = "user_responses = list()  # list of user specified actions"
class_def_pattern = "^class\s+"
class_def_found = False
for line_num, line in enumerate(lines):
    match = re.match(class_def_pattern, line)
    if match != None:
        # found line with class definition.  Insert declaration and break
        # out of loop
        lines.insert(line_num, "")
        lines.insert(line_num, line_to_insert)
        class_def_found = True
        break
if class_def_found == False:
    sys.exit("Failed to add declaration for list user_responses")


## Add explicit waits for certain HTML elements to be loaded (e.g. start
## button, canvas, etc)
# To add an explicit wait, call function make_wait_command with max time to
# wait and how the element is found by Selenium (e.g. By.NAME).
# The return value will a list of strings, where each string is a line to be
# inserted into the enhanced script
# Add explicit wait for start button (By.name, "control").
control_btn_pattern = '\s*self\.driver\.find_element\(By.NAME, "control"\)'
cmd_to_insert = make_wait_command(120, 'By.NAME, "control"') 
for line_num, line in enumerate(lines):
    match = re.match(control_btn_pattern, line)
    if match != None:
        # found line that clicks control button.  Insert wait for button to be
        # clickable and exit
        
        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # Form the line to write with num_spaces in front of the command to
        # insert.  To do this find the total length of the line to be inserted
        # (num of spaces + length of the command), and write the command to a
        # string with right justification
        num_lines_inserted = 0
        for l in cmd_to_insert:
            total_line_len = num_spaces + len(l)
            line_to_insert = l.rjust(total_line_len, ' ')

            # insert line after current line
            lines.insert(line_num+num_lines_inserted, line_to_insert)
            num_lines_inserted += 1
        break

# Add explicit wait for canvas to be ready AFTER start ("control") button
# is clicked
control_btn_pattern = '\s*self\.driver\.find_element\(By.NAME, "control"\)'
cmd_to_insert = make_wait_command(360, 'By.CSS_SELECTOR, "canvas"')
for line_num, line in enumerate(lines):
    match = re.match(control_btn_pattern, line)
    if match != None:
        # found line that clicks control button.  Insert wait for canvas 
        # to load after control button is clicked.

        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # Form the line to write with num_spaces in front of the command to
        # to insert
        num_lines_inserted = 0
        for l in cmd_to_insert:
            total_line_len = num_spaces + len(l)
            line_to_insert = l.rjust(total_line_len, ' ')

            # insert line after current line
            lines.insert(line_num+num_lines_inserted+1, line_to_insert)
            num_lines_inserted += 1
        break

# Add explicit wait before click of button confirming ending of lab
confirm_end_btn_pattern = '^\s*self\.driver\.find_element\(By.ID, "btnConfirmEndExercise"\)'
cmd_to_insert = make_wait_command(120, 'By.ID, "btnConfirmEndExercise"')
for line_num, line in enumerate(lines):
    match = re.match(confirm_end_btn_pattern, line)
    if match != None:
        # found line that clicks button to confirm ending lab.
        # Insert wait for button to load

        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # Form the line to write with num_spaces in front of the command to
        # to insert
        num_lines_inserted = 0
        for l in cmd_to_insert:
            total_line_len = num_spaces + len(l)
            line_to_insert = l.rjust(total_line_len, ' ')

            # insert line after current line
            lines.insert(line_num+num_lines_inserted, line_to_insert)
            num_lines_inserted += 1
        break
    

## Add call to function.prompt_user before any action on canvas
canvas_action_pattern = '^\s*\w+\s*=\s*self\.driver\.find_element\(By\.CSS_SELECTOR, "canvas"\)'
cmd_to_insert = "user_responses.append((getframeinfo(currentframe()).lineno, functions.prompt_user()))" # adds a tuple with the line number and the user response to the list
line_num = 0 # current line number in lines being processed
while line_num < len(lines):
    match = re.match(canvas_action_pattern, lines[line_num])
    if match != None:
        # found line with action on canvas.  Insert call to prompt_user after
        # this line

        # find indentation of current line (num spaces)
        num_spaces = len(line) - len(line.lstrip()) 

        # add necessary number of spaces before cmd_to_insert 
        total_line_len = num_spaces + len(cmd_to_insert)
        line_to_insert = cmd_to_insert.rjust(total_line_len, ' ')

        # insert line before current line and increment line_num
        lines.insert(line_num, line_to_insert)
        line_num += 1  # since we added a line
    line_num += 1  # go to next line
    
## find name of the test class and test method created by Selenium
test_class_name = test_method_name = None
curr_line_num = 0
while test_class_name == None or test_method_name == None:
    if re.match("^\s*class\s+", lines[curr_line_num]) != None: 
        # Found line that starts with "class ". Get the second part of the line
        # which will have the name of the class
        test_class_name = lines[curr_line_num].split()[1]

        # Get rid of the "():" that is appended to the class name
        test_class_name = test_class_name.replace("():", "")

    if re.match("^\s*def\s*test_", lines[curr_line_num]) != None:
        # Found line that starts "def test_".  Get the second part of the line
        # which will have the name of the method
        test_method_name = lines[curr_line_num].split()[1]

        # Get rid of the "(self):" that is appended to the method name
        test_method_name = test_method_name.replace("(self):", "") 

    curr_line_num += 1

# inserts calls to create test class and to run test
lines.insert(len(lines)-1, "\ntestClass = " + test_class_name + "()")
lines.insert(len(lines)-1, 'testClass.setup_method("")')
lines.insert(len(lines)-1, "testClass." + test_method_name + "()")
lines.insert(len(lines)-1, 'testClass.teardown_method("")')
        
# done inserting lines.  Write all lines to enhanced file
with open(enhanced_file_name, 'w') as ef:
    for line_num, line in enumerate(lines):
        ef.write(line + '\n')

sys.exit("Created file " + enhanced_file_name)